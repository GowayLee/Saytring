# String Processing Compiler

Our compiler is designed to compile a new programming language "Saytring". We will firstly introduce the features of Saytring, after that, is the description of Saytring compiler.

## Description

## Language Design

We have designed Saytring, a new programming language for specialized string processing tasks. The Saytring compiler translates Saytring source code into Python, leveraging Python's flexibility. Saytring is user-friendly, experimental, and intuitive, focusing on simplifying string manipulation for non-professional programmers.

### Syntax and Type System

Saytring's syntax mimics natural language, making it intuitive and easy to learn. It includes syntactic sugars like chain calls and arithmetic operations for strings, enhancing readability. The `ask` and `say` commands handle input and output naturally, while chain calls enable seamless function sequencing.

Saytring's Type System operates on strings but incorporates dynamic type management, mimicking static type checking for safety. It supports type inference and includes functions for explicit type casting, such as `cast_null_to_str()` and `cast_null_to_int()`.

### Dynamic Properties and Runtime

Saytring introduces Dynamic Properties, allowing variables to store additional information. These properties, like `last_result`, enhance data management and support complex workflows. The Saytring Runtime Environment, implemented in Python, provides utility functions and built-in operations for string processing, designed to be extensible.

### Error Handling, Built-in Functions, and Operations

The runtime includes comprehensive error handling to manage type mismatches and invalid operations, ensuring programs continue executing safely. Built-in functions simplify tasks like string reversal and concatenation, while extended arithmetic and comparison operations work intuitively with strings.

### Input/Output Operations and Extensibility

The runtime supports input/output with functions like `ask()` and `say()`, enabling interactive programs. The modular design ensures high extensibility, allowing developers to add new functions and features, supporting evolving needs.

## Compiler Design

The String Processing Compiler for the Saytring language is designed to efficiently handle the compilation process through multiple phases, leveraging the capabilities of Flex and Bison. The compilation process can be divided into several key phases, each serving a specific purpose in transforming Saytring source code into executable Python code.

### Lexical Analysis

The first phase of the compilation process is lexical analysis, which is performed by Flex. Flex is used to generate the lexical analyzer, which reads the input Saytring source code and breaks it down into meaningful tokens. These tokens represent the basic building blocks of the language, such as keywords, identifiers, literals, and operators. The lexical analyzer ensures that the source code is tokenized accurately, taking into account the dynamic and flexible syntax of Saytring, including its syntactic sugars and chain calls. This phase is crucial for preparing the input for subsequent stages of the compilation process.

### Syntax Analysis

The second phase is syntax analysis, which is handled by Bison. Bison takes the tokens generated by Flex and performs syntax analysis to construct the Abstract Syntax Tree (AST). The AST is a hierarchical representation of the source code, capturing the structure and semantics of the program according to the defined grammar rules. Bison ensures that the syntax of the Saytring code is validated and that the AST accurately reflects the intended program logic. This phase is essential for ensuring that the source code adheres to the language's grammar and can be further processed by the compiler.

### Semantic Analysis and Code Generation

Following syntax analysis, the compiler performs semantic analysis and code generation. During semantic analysis, the compiler checks the AST for semantic correctness, such as type compatibility and variable usage. This phase ensures that the program is not only syntactically correct but also semantically sound. Once the semantic analysis is complete, the compiler generates Python code from the AST. The generated Python code leverages the Saytring Runtime Environment to execute the string processing tasks defined in the Saytring source code. This phase is critical for translating the high-level Saytring code into a form that can be executed by the Python runtime.

### Integration of Flex and Bison

The integration of Flex and Bison in the compiler design ensures that the compilation process is both efficient and accurate. Flex and Bison work together to handle the dynamic and flexible syntax of Saytring, enabling the compiler to accurately process syntactic sugars and chain calls. The design philosophy of the compiler aligns with the user-friendly and experimental nature of Saytring, making it an ideal tool for exploring the innovative features of the language. By leveraging Flex and Bison, the compiler achieves a harmonious balance between simplicity and functionality, ensuring that the compilation process is both intuitive and robust.

---

## Code and Explanation

## Symbol Table and Pre-defined Symbols

The `symtab.h` and `symtab.cc` files define the symbol table and related classes for the Saytring compiler. The symbol table is a critical component in the compiler, responsible for managing identifiers, ensuring uniqueness, and storing predefined symbols. This section provides an overview of the symbol table and its role in the compiler, along with examples of pre-defined symbols.

### Symbol Table Overview

The symbol table is implemented using the `String_Tab` class, which stores a collection of `Symbol` objects. Each `Symbol` represents a unique identifier or predefined symbol in the Saytring language. The `String_Tab` ensures that identifiers with the same name are unique by checking for duplicates before adding a new symbol.

#### Example: Adding a Symbol to the Symbol Table

The `add_string` method in the `String_Tab` class is responsible for adding new symbols to the symbol table. It checks if a symbol with the same name already exists and returns the existing symbol if found. If not, it creates a new `Symbol` and adds it to the table.

```cpp
Symbol *String_Tab::add_string(char *s) {
  Symbol *new_sym = new Symbol(s);
  for (Symbol *sym : *symtab) {
    if (*new_sym == *sym) { // If find same symbol, return it
      delete new_sym;
      return sym;
    }
  }
  this->symtab->push_back(new_sym);
  return new_sym;
}
```

- **Symbol Creation**: A new `Symbol` object is created using the provided string.
- **Duplicate Check**: The method iterates through the existing symbols in the table to check for duplicates.
- **Uniqueness**: If a duplicate is found, the new symbol is deleted, and the existing symbol is returned. Otherwise, the new symbol is added to the table.

### Pre-defined Symbols

The Saytring compiler includes several pre-defined symbols that represent basic types, operators, and special identifiers. These symbols are initialized at the start of the compiler and are used throughout the compilation process.

#### Example: Pre-defined Basic Types

The following code initializes pre-defined symbols for basic types in Saytring:

```cpp
Symbol *_string = id_tab->add_string("_string");
Symbol *_int = id_tab->add_string("_int");
Symbol *_list = id_tab->add_string("_list");
Symbol *_bool = id_tab->add_string("_bool");
Symbol *NULL_Type = id_tab->add_string("NULL_Type");
Symbol *ERR_Type = id_tab->add_string("ERR_Type");
Symbol *LAST_RESULT = id_tab->add_string("last_result");
```

- **Basic Types**: These symbols represent the basic types in Saytring, such as `_string`, `_int`, `_list`, and `_bool`.
- **Special Types**: `NULL_Type` and `ERR_Type` represent special types used for null values and error handling, respectively.
- **Dynamic Property**: `LAST_RESULT` is a dynamic property that stores the result of the last operation.

#### Example: Pre-defined Operators

The following code initializes pre-defined symbols for operators in Saytring:

```cpp
Symbol *_ADD = new Symbol("ADD");
Symbol *_SUB = new Symbol("SUB");
Symbol *_GT = new Symbol("GT");
Symbol *_LT = new Symbol("LT");
Symbol *_GE = new Symbol("GE");
Symbol *_LE = new Symbol("LE");
Symbol *_EQ = new Symbol("EQ");
Symbol *_NE = new Symbol("NE");
```

- **Arithmetic Operators**: These symbols represent arithmetic operators such as addition (`ADD`) and subtraction (`SUB`).
- **Comparison Operators**: These symbols represent comparison operators such as greater than (`GT`), less than (`LT`), and equality (`EQ`).

### Lexical Analysis with Flex

The lexical analyzer, generated by Flex, is a critical component of the Saytring compiler, responsible for transforming the raw Saytring source code into a sequence of meaningful tokens. These tokens are the fundamental building blocks that the parser uses to construct the Abstract Syntax Tree (AST). The Flex-generated lexer is designed to handle the dynamic and flexible syntax of Saytring, including its syntactic sugars and chain calls. Below, we provide a detailed analysis of key sections of the Flex code, focusing on how the lexer handles different types of tokens, including inline comments, string constants, and keywords/identifiers.

#### Handling Inline Comments

Inline comments are a common feature in many programming languages, and Saytring is no exception. In Saytring, inline comments start with a `#` and continue until the end of the line. The following code block illustrates how the lexer handles inline comments:

```c
"#"                                                   BEGIN(INLINE_COMMENT);
<INLINE_COMMENT>"\n"                                  {
  yylineno++;
  yycolumn = 1;
  BEGIN(INITIAL);
}
<INLINE_COMMENT>.                                     ;
```

- **State Transition**: When the lexer encounters a `#`, it transitions to the `INLINE_COMMENT` state using the `BEGIN(INLINE_COMMENT)` directive.
- **Character Handling**: In the `INLINE_COMMENT` state, any character that is not a newline is ignored. This ensures that the lexer skips over the comment text without generating tokens.
- **Line and Column Management**: When a newline character is encountered, the lexer increments the line number (`yylineno++`) and resets the column number (`yycolumn = 1`). It then returns to the initial state (`BEGIN(INITIAL)`), ready to process the next line of code.

#### Handling String Constants

String constants are a fundamental part of Saytring, used to represent textual data within the program. Saytring string constants are enclosed in double quotes and may include escape sequences. The following code block demonstrates how the lexer handles string constants, including error conditions such as unterminated strings and null characters:

```c
"\""                                                  {
 BEGIN(NORMAL_STRING_CONST);
 reset_string_buf();
}
<NORMAL_STRING_CONST>"\\"                             is_escape = true;
<NORMAL_STRING_CONST>"\n"                             {
  yylineno++;
  yycolumn = 1;
  if (is_escape) {
    is_escape = false;
  } else {
    BEGIN(ERROR_STRING_CONST);
    yylval.error_msg = "Unterminated string constant";
    return ERROR;
  }
}
<NORMAL_STRING_CONST>"\""                             {
  *string_buf_ptr = '\0';
  BEGIN(INITIAL);
 yylval.symbol = str_tab->add_string(string_buf);
 return STR_CONST;
}
<NORMAL_STRING_CONST>[^\0]*\0                         {
  BEGIN(ERROR_STRING_CONST);
  yylval.error_msg = "String contains null character";
  return ERROR;
}
<NORMAL_STRING_CONST><<EOF>>                          {
  BEGIN(INITIAL);
  yylval.error_msg = "EOF in string constant";
  return ERROR;
}
<NORMAL_STRING_CONST>.                                {
 *string_buf_ptr = yytext[0];

  // Check if the string is too long
  if (++string_buf_ptr >= MAX_STR_BUF_LOC) {
    BEGIN(ERROR_STRING_CONST);
    yylval.error_msg = "String constant too long";
    return ERROR;
  }
}
```

- **State Transition**: When the lexer encounters a `"`, it transitions to the `NORMAL_STRING_CONST` state and resets the string buffer using `reset_string_buf()`.
- **Escape Sequences**: Inside the `NORMAL_STRING_CONST` state, the lexer handles escape sequences by setting the `is_escape` flag to `true` when a backslash (`\\`) is encountered. This flag is used to differentiate between escape sequences and actual newline characters.
- **Error Handling**: The lexer checks for several error conditions:
  - **Unterminated Strings**: If a newline is encountered without an escape sequence, the lexer transitions to the `ERROR_STRING_CONST` state and returns an `ERROR` token with the message "Unterminated string constant".
  - **Null Characters**: If a null character (`\0`) is found within the string, the lexer transitions to the `ERROR_STRING_CONST` state and returns an `ERROR` token with the message "String contains null character".
  - **EOF in String**: If the end of the file is reached before the string is closed, the lexer returns an `ERROR` token with the message "EOF in string constant".
  - **String Length Limit**: The lexer also checks if the string exceeds the maximum allowed length (`MAX_STR_BUF_LOC`). If it does, the lexer transitions to the `ERROR_STRING_CONST` state and returns an `ERROR` token with the message "String constant too long".
- **String Completion**: If a valid string is completed (i.e., a closing `"` is found), the lexer appends a null terminator to the string buffer, transitions back to the initial state, and returns the `STR_CONST` token.

#### Handling Keywords and Identifiers

Keywords and identifiers are essential components of the Saytring language, used to define the structure and semantics of the program. The following code block demonstrates how the lexer distinguishes between keywords and identifiers:

```c
{ID}                                                  {
  yylval.symbol = id_tab->add_string(yytext);
  return ID;
}

(?i:d)efine                                           return DEFINE;
(?i:i)f                                               return IF;
(?i:a)sk                                              return ASK;
(?i:s)et                                              return SET;
(?i:s)ay                                              return SAY;
(?i:c)onvert                                          return CONVERT;
"as"                                                  return AS;
"has"                                                 return HAS;
"do"                                                  return DO;
"using"                                               return USING;
"on"                                                  return ON;
"then"                                                return THEN;
"else"                                                return ELSE;
"endif"                                               return ENDIF;
"to"                                                  return TO;
```

- **Identifier Matching**: The lexer uses a regular expression (`{ID}`) to match identifiers, which are sequences of letters, digits, and underscores starting with a lowercase letter. When an identifier is matched, the lexer adds it to the identifier table using `id_tab->add_string(yytext)` and returns the `ID` token.
- **Keyword Matching**: Keywords are matched using case-insensitive regular expressions (e.g., `(?i:d)efine` matches "define" regardless of case). When a keyword is matched, the lexer returns the corresponding token (e.g., `DEFINE`, `IF`, `ASK`).
- **Token Generation**: The lexer ensures that both keywords and identifiers are correctly identified and passed to the parser for further processing. This distinction is crucial for maintaining the semantic integrity of the Saytring program.

### Syntax Analysis with Bison

The syntax analyzer, generated by Bison, plays a critical role in the Saytring compiler by parsing the tokens generated by Flex and constructing the Abstract Syntax Tree (AST). The AST is a hierarchical representation of the Saytring program, capturing the relationships between different elements of the code. This section provides a detailed analysis of key sections of the Bison code, focusing on how the syntax analyzer handles various constructs in the Saytring language.

#### Program Structure

The `program` rule is the entry point of the grammar and defines the structure of a Saytring program. A Saytring program consists of a list of expressions, which are processed and stored in the `global_expr_list`. The following code block illustrates how the syntax analyzer constructs the AST for the program:

```y
program : expr_list
        {
          ast_root = new Program(global_expr_list, YYLTYPE());
        }
        ;
```

- **Program Rule**: The `program` rule is the starting point of the grammar.
- **Expression List**: It expects a list of expressions (`expr_list`), which are processed and stored in the `global_expr_list`.
- **AST Construction**: The `ast_root` is created as a `Program` object, encapsulating the list of expressions and their locations in the source code. This object serves as the root of the AST, representing the entire program.

#### Expression Handling

Expressions are the fundamental building blocks of a Saytring program. The `expression` rule is recursive and can match various types of expressions, including assignment, input/output, conditional statements, identifiers, type casting, constants, declarations, property declarations, and function calls. The following code block demonstrates how the syntax analyzer handles different types of expressions:

```y
expression : assi_expr        { $$ = $1; }
           | io_expr          { $$ = $1; }
           | cond_expr        { $$ = $1; }
           | identifier       { $$ = $1; }
           | cast_expr        { $$ = $1; }
           | const_expr       { $$ = $1; }
           | decl_expr          ;
           | property_decl_expr ;
           | call_expr          ;
           | expression comp_op expression ';'
           {
             if (!has_pushed_back)
               $$ = new Comp_Expr($1, $2, $3, @1);
             else {
               $$ = new Comp_Expr($1, $2, temp_return_id, @1);
               has_pushed_back = false;
             }
           }
           | expression arith_op expression ';'
           {
             if (!has_pushed_back)
               $$ = new Arith_Expr($1, $2, $3, @1);
             else {
               $$ = new Arith_Expr($1, $2, temp_return_id, @1);
               has_pushed_back = false;
             }
           }
           | error '\n'
           {
             yyerror("Error in expression", yylloc);
             yyerrok;
           }
           ;
```

- **Expression Types**: The `expression` rule can match various types of expressions, including assignment (`assi_expr`), input/output (`io_expr`), conditional (`cond_expr`), identifiers, type casting (`cast_expr`), constants (`const_expr`), declarations (`decl_expr`), property declarations (`property_decl_expr`), and function calls (`call_expr`).
- **Binary Operations**: The rule also handles binary operations such as comparisons (`comp_op`) and arithmetic operations (`arith_op`). For example, when a comparison or arithmetic operation is encountered, a `Comp_Expr` or `Arith_Expr` object is created, respectively.
- **Error Handling**: If an error is encountered, the syntax analyzer reports it using the `yyerror` function and continues parsing using `yyerrok`. This allows the compiler to recover from errors and attempt to parse the rest of the source code.

#### Function Calls and Chain Calls

Function calls and chain calls are essential features of Saytring, allowing for sequential execution of functions. The `call_expr` rule handles function calls, either with an identifier or a constant expression as the caller. The `dummy_chain_call_list` rule collects a list of function expressions (`func_expr`) and handles chain calls using the `CHAIN` keyword. The following code block illustrates how the syntax analyzer handles these constructs:

```y
call_expr : identifier dummy_chain_call_list
          {
            parse_funcs($1);
          }
          | const_expr dummy_chain_call_list
          {
            Identifier *anony_caller = new Single_Identifier(_anonymous, @1);
            global_expr_list->push_back(new Assi_Expr(anony_caller, $1, @1));
            parse_funcs(anony_caller);
          }
          ;

dummy_chain_call_list : func_expr
                      {
                        temp_call_list->clear();
                        temp_call_list->push_back($1);
                      }
                      | func_expr CHAIN dummy_chain_call_list
                      {
                        temp_call_list->push_back($1);
                      }
                      | '(' IF expression THEN func_expr ')'
                      {
                        temp_call_list->clear();
                        temp_call_list->push_back(new Cond_Call_Expr($3, $5, @3));
                      }
                      | '(' IF expression THEN func_expr ')' CHAIN dummy_chain_call_list
                      {
                        temp_call_list->push_back(new Cond_Call_Expr($3, $5, @3));
                      }
                      | CHAIN error
                      {
                        yyerror("Error in chain call", yylloc);
                        yyerrok;
                      }
                      ;
```

- **Function Calls**: The `call_expr` rule handles function calls, either with an identifier or a constant expression as the caller.
- **Chain Calls**: The `dummy_chain_call_list` rule collects a list of function expressions (`func_expr`) and handles chain calls using the `CHAIN` keyword. This allows for sequential execution of functions.
- **Conditional Calls**: Conditional calls are also supported, where an `IF` expression determines whether a function should be executed. The syntax analyzer constructs a `Cond_Call_Expr` object to represent these conditional calls.
- **Function Processing**: The `parse_funcs` function processes the collected function calls, ensuring that the correct caller and return identifiers are used. This function is crucial for maintaining the correct execution order and context in chain calls.

#### Error Handling

Error handling is a critical aspect of the syntax analyzer, ensuring that the compiler can recover from syntax errors and continue parsing. The following code block demonstrates how the syntax analyzer handles errors:

```y
expression : error '\n'
           {
             yyerror("Error in expression", yylloc);
             yyerrok;
           }
           ;
```

- **Error Token**: The `error` token is used to indicate a syntax error.
- **Error Reporting**: When an error is encountered, the syntax analyzer reports it using the `yyerror` function, providing detailed information about the error location and nature.
- **Error Recovery**: The `yyerrok` function allows the compiler to recover from errors and continue parsing the rest of the source code. This ensures that the compiler can handle multiple errors and provide comprehensive feedback to the user.

### Abstract Syntax Tree (AST) and Nodes

The `AST.h` file defines the structure of the Abstract Syntax Tree (AST) for the Saytring compiler. The AST is a hierarchical representation of the source code, capturing the relationships between different elements of the program. Each node in the AST represents a specific construct in the Saytring language, such as expressions, declarations, and function calls. The AST is constructed during the syntax analysis phase using Bison and is used in subsequent phases for semantic analysis and code generation.

#### AST Node Structure

The base class for all AST nodes is `AST_Node`, which includes a `YYLTYPE` object to store the location information of the node in the source code. This location information is crucial for error reporting and debugging.

```cpp
class AST_Node {
public:
  YYLTYPE location;
  AST_Node(YYLTYPE loc) { this->location = loc; }
};
```

- **Location Information**: The `YYLTYPE` object stores the line and column numbers of the node in the source code, which is used for error reporting and debugging.

#### Program Node

The `Program` class represents the root of the AST and encapsulates a list of expressions that make up the Saytring program.

```cpp
class Program : public AST_Node {
public:
  std::vector<class Expression *> *expr_list;
  Program(std::vector<Expression *> *expr, YYLTYPE loc) : AST_Node(loc) {
    this->expr_list = expr;
  }

  void semant_check();
  void code_generation();
};
```

- **Expression List**: The `expr_list` contains all the expressions in the program, which are processed during the semantic analysis and code generation phases.
- **Semantic Check**: The `semant_check()` function is called to perform semantic analysis on the program.
- **Code Generation**: The `code_generation()` function is called to generate Python code from the AST.

#### Expression Node

The `Expression` class is the base class for all expression nodes in the AST. It includes a `Symbol` pointer to store the type of the expression.

```cpp
class Expression : public AST_Node {
public:
  Symbol *type;
  Expression(YYLTYPE loc) : AST_Node(loc) {}
  virtual Symbol *type_check() = 0;
  void code_generate(std::ostringstream &generated_code);
  virtual std::string code_generate() = 0;
};
```

- **Type Information**: The `type` pointer stores the type of the expression, which is determined during the semantic analysis phase.
- **Type Check**: The `type_check()` function is a pure virtual function that must be implemented by derived classes to perform type checking.
- **Code Generation**: The `code_generate()` function is a pure virtual function that must be implemented by derived classes to generate code for the expression.

#### Identifier Nodes

The `Identifier` class is the base class for all identifier nodes in the AST. It includes functions to check if the identifier has an owner or if it represents a `nil` value.

```cpp
class Identifier : public Expression {
public:
  Identifier(YYLTYPE loc) : Expression(loc) {}
  virtual bool has_owner() = 0;
  virtual bool is_nil() = 0;
  virtual Symbol *type_check() = 0;
  virtual std::string code_generate() = 0;
};
```

- **Owner Check**: The `has_owner()` function checks if the identifier belongs to an owner (e.g., a property of an object).
- **Nil Check**: The `is_nil()` function checks if the identifier represents a `nil` value.

#### Call Expression Nodes

The `Call_Expr` class is the base class for all function call nodes in the AST. It includes functions to determine if the call is conditional.

```cpp
class Call_Expr : public Expression {
public:
  Call_Expr(YYLTYPE loc) : Expression(loc) {}
  virtual bool is_cond_call() = 0;
  virtual Symbol *type_check() = 0;
  virtual std::string code_generate() = 0;
};
```

- **Conditional Call Check**: The `is_cond_call()` function checks if the function call is conditional (i.e., depends on a condition).

#### Direct Call Expression

The `Direct_Call_Expr` class represents a direct function call in the AST. It includes an identifier for the caller, a function name, a list of arguments, and an identifier for the return value.

```cpp
class Direct_Call_Expr : public Call_Expr {
public:
  Identifier *id;
  Symbol *func_name;
  std::vector<Expression *> *arg_list;
  Identifier *return_id;
  Direct_Call_Expr(Identifier *id, Symbol *func_name,
                   std::vector<Expression *> *arg_list, Identifier *return_id,
                   YYLTYPE loc)
      : Call_Expr(loc) {
    this->id = id;
    this->func_name = func_name;
    this->arg_list = arg_list;
    this->return_id = return_id;
  }

  Direct_Call_Expr(Symbol *func_name, std::vector<Expression *> *arg_list,
                   Identifier *return_id, YYLTYPE loc)
      : Call_Expr(loc) {
    this->func_name = func_name;
    this->arg_list = arg_list;
    this->return_id = return_id;
  }
  bool is_cond_call() { return false; }
  Symbol *type_check();
  std::string code_generate();
};
```

- **Caller Identifier**: The `id` pointer stores the identifier of the caller.
- **Function Name**: The `func_name` pointer stores the name of the function being called.
- **Argument List**: The `arg_list` contains the list of arguments passed to the function.
- **Return Identifier**: The `return_id` pointer stores the identifier where the return value will be stored.

#### Constant Expression Nodes

The `Const_Expr` class is the base class for all constant expression nodes in the AST. It represents literal values such as strings, integers, and boolean values.

```cpp
class Const_Expr : public Expression {
public:
  Const_Expr(YYLTYPE loc) : Expression(loc) {}
};
```

- **Literal Values**: The `Const_Expr` class serves as a base for specific constant types like strings, integers, and booleans.

#### String Constant Expression

The `String_Const_Expr` class represents a string constant in the AST. It includes a `Symbol` pointer to store the string token.

```cpp
class String_Const_Expr : public Const_Expr {
public:
  Symbol *token;
  String_Const_Expr(Symbol *token, YYLTYPE loc) : Const_Expr(loc) {
    this->token = token;
  }
  Symbol *type_check();
  std::string code_generate();
};
```

- **String Token**: The `token` pointer stores the string literal value.

#### Integer Constant Expression

The `Int_Const_Expr` class represents an integer constant in the AST. It includes a `Symbol` pointer to store the integer token.

```cpp
class Int_Const_Expr : public Const_Expr {
public:
  Symbol *token;
  Int_Const_Expr(Symbol *token, YYLTYPE loc) : Const_Expr(loc) {
    this->token = token;
  }
  Symbol *type_check();
  std::string code_generate();
};
```

- **Integer Token**: The `token` pointer stores the integer literal value.

#### Boolean Constant Expression

The `Bool_Const_Expr` class represents a boolean constant in the AST. It includes a boolean value to store the truth value.

```cpp
class Bool_Const_Expr : public Const_Expr {
public:
  bool value;
  Bool_Const_Expr(bool value, YYLTYPE loc) : Const_Expr(loc) {
    this->value = value;
  }
  Symbol *type_check();
  std::string code_generate();
};
```

- **Boolean Value**: The `value` field stores the boolean literal value (`true` or `false`).

### Semantic Analysis and Type Checking

Semantic analysis is a crucial phase in the compilation process, ensuring that the program not only adheres to the syntax rules but also makes logical sense in terms of types, variable usage, and function calls. In the Saytring compiler, semantic analysis is primarily handled by the `type_check()` functions, which are implemented for each type of expression in the AST. These functions ensure that the types of expressions are compatible and that variables are used correctly.

#### Type Environment and Context Management

The type environment is managed through the `Env` class, which maintains several maps to keep track of variable types, property types, and function signatures. The `id_map` stores the types of single identifiers, while the `property_map` stores the types of properties that belong to specific owners. The `func_map` keeps track of function signatures, including the types of their arguments and return values.

The `Env` class provides several static methods to interact with these maps, such as `get_id_type()` to retrieve the type of an identifier, and `update_id_type_info()` to update the type information of an identifier. These methods are used throughout the `type_check()` functions to ensure that the type environment is consistent and up-to-date.

#### Example: Type Checking for Variable Declarations

The `Var_Decl_Expr` class represents a variable declaration in the AST. The `type_check()` function for this class ensures that the variable is not declared multiple times and that the initialization expression has a valid type. If the initialization expression is of type `NULL_Type`, a warning is issued.

```cpp
Symbol *Var_Decl_Expr::type_check() {
  if (Env::id_map->find(identifier) != Env::id_map->end())
    semant_warn(this) << "Duplicate declaration of variable \""
                      << identifier->get_string() << "\"" << std::endl;
  init->type = init->type_check();
  if (init->type == ERR_Type)
    return ERR_Type;
  if (init->type == NULL_Type) {
    semant_warn(this)
        << "Should not initialize a variable with NULL_Type value!"
        << std::endl;
  }
  Env::id_map->insert(std::make_pair(identifier, init->type));
  return NULL_Type;
}
```

- **Duplicate Declaration Check**: The function first checks if the variable has already been declared by looking it up in the `id_map`. If it has, a warning is issued.
- **Initialization Expression Type Check**: The type of the initialization expression is checked by calling its `type_check()` function. If the type is `ERR_Type`, the function returns `ERR_Type` to indicate an error.
- **NULL_Type Warning**: If the initialization expression is of type `NULL_Type`, a warning is issued, as initializing a variable with `NULL_Type` is generally not recommended.
- **Update Type Environment**: Finally, the variable's type is added to the `id_map` to ensure that it is available for subsequent type checks.

#### Example: Type Checking for Function Calls

The `Direct_Call_Expr` class represents a direct function call in the AST. The `type_check()` function for this class ensures that the function exists, that the caller and arguments have the correct types, and that the return type is correctly assigned.

```cpp
Symbol *Direct_Call_Expr::type_check() {
  id->type = id->type_check();
  if (id->type == ERR_Type)
    return ERR_Type;
  return_id->type = return_id->type_check();
  if (id->type == ERR_Type)
    return ERR_Type;

  // Check function
  auto it = Env::func_map->find(func_name);
  if (it == Env::func_map->end()) {
    semant_error(this) << "Undefined function \"" << func_name->get_string()
                       << "\" is called!" << std::endl;
    return ERR_Type;
  }
  std::vector<Symbol *> *func_arg_list = it->second;

  // Do type-check for arg_list
  // Check number of args
  size_t func_arg_list_size = func_arg_list->size();
  size_t actual_arg_list_size = arg_list->size();
  // function caller_id is the 1st arg
  // func_arg_list contain return_type. So -2
  if (func_arg_list_size - 2 > actual_arg_list_size) {
    semant_error(this) << "Missing args for function \""
                       << func_name->get_string() << "\", require "
                       << func_arg_list->size() - 2 << " args!" << std::endl;
    return ERR_Type;
  } else if (func_arg_list_size - 2 < actual_arg_list_size) {
    semant_error(this) << "Too more args for function \""
                       << func_name->get_string() << "\", require "
                       << func_arg_list->size() - 2 << " args!" << std::endl;
    return ERR_Type;
  }
  // Check type
  // First check function caller, which is at the back of actual_arg_list
  id->type = id->type_check();
  if (id->type == ERR_Type)
    return ERR_Type;
  if (func_arg_list->at(0) != id->type)
    semant_warn(this) << "The variable calling function does not match proper "
                         "type! Required: \""
                      << func_arg_list->at(0)->get_string() << "\", Actual \""
                      << id->type->get_string() << "\"" << std::endl;
  // Then check rest args
  for (size_t i = 1; i < func_arg_list_size - 1; i++) {
    Symbol *func_arg_type = func_arg_list->at(i);
    // Arguments are collected in inverse order
    Expression *cur_arg = arg_list->at(actual_arg_list_size - i);
    cur_arg->type = cur_arg->type_check();
    Symbol *actual_arg_type = arg_list->at(actual_arg_list_size - i)->type;
    if (actual_arg_type == ERR_Type)
      return ERR_Type;
    if (actual_arg_type == NULL_Type)
      semant_warn(this)
          << "Should never pass a NULL_Type variable as parameter."
          << std::endl;
    if (actual_arg_type != func_arg_type)
      semant_warn(this) << "Calling function \"" << func_name->get_string()
                        << "\", the " << i
                        << "th arg is different with the required! Required: \""
                        << func_arg_type->get_string() << "\", Actual: \""
                        << actual_arg_type->get_string() << "\"" << std::endl;
  }
  // Update type information of return_id
  Env::update_id_type_info(return_id, func_arg_list->back());
  return func_arg_list->back();
}
```

- **Function Existence Check**: The function first checks if the function exists by looking it up in the `func_map`. If the function is not found, an error is issued.
- **Argument Count Check**: The function then checks if the number of arguments provided matches the number required by the function. If there are too few or too many arguments, an error is issued.
- **Argument Type Check**: The types of the arguments are checked against the expected types. If any argument does not match the expected type, a warning is issued.
- **Return Type Update**: Finally, the return type of the function is assigned to the return identifier, and the type information is updated in the `id_map`.

#### Core Functions and Type Casting Maps

The Saytring compiler includes predefined functions and type casting maps to handle common operations and type conversions. These predefined functions and type casting maps are installed during the semantic analysis phase to ensure that the compiler can handle built-in operations and type conversions efficiently.

##### Example: Installing Predefined Functions

The `install_buildin_func()` function installs predefined functions into the `func_map`. These functions include type casting operations and other utility functions.

```cpp
void install_buildin_func() {
  std::vector<Symbol *> *arg_list;

  // Type-cast Functions
  // cast_int_to_str(int) : string
  arg_list = new std::vector<Symbol *>;
  arg_list->push_back(_int);
  arg_list->push_back(_string); // return_type
  Env::func_map->insert(
      std::make_pair(id_tab->add_string("cast_int_to_str"), arg_list));

  // cast_bool_to_str(bool) : string
  arg_list = new std::vector<Symbol *>;
  arg_list->push_back(_bool);
  arg_list->push_back(_string); // return_type
  Env::func_map->insert(
      std::make_pair(id_tab->add_string("cast_bool_to_str"), arg_list));

  // cast_list_to_str(list) : string
  arg_list = new std::vector<Symbol *>;
  arg_list->push_back(_list);
  arg_list->push_back(_string); // return_type
  Env::func_map->insert(
      std::make_pair(id_tab->add_string("cast_list_to_str"), arg_list));

}
```

This function installs a variety of predefined functions into the `func_map`, including type casting functions, string manipulation functions, and utility functions for input/output operations. These functions are essential for handling common operations and ensuring that the compiler can perform type conversions efficiently during semantic analysis.

##### Example: Installing Type Casting Maps

The `install_type_cast_map()` function installs type casting maps into the `type_cast_map`. This map is used to determine the appropriate function to call for type casting between different types.

```cpp
void install_type_cast_map() {
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_int, _string, "cast_int_to_str"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_int, _bool, "cast_int_to_bool"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_string, _int, "cast_str_to_int"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_string, _bool, "cast_str_to_bool"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_bool, _string, "cast_bool_to_str"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_bool, _int, "cast_bool_to_int"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(_list, _string, "cast_list_to_str"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(NULL_Type, _string, "cast_null_to_str"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(NULL_Type, _int, "cast_null_to_int"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(NULL_Type, _bool, "cast_null_to_bool"));
  type_cast_map->insert(TYPE_CAST_MAP_ENTRY(NULL_Type, _string, "cast_null_to_str"));
}
```

This function installs type casting entries into the `type_cast_map`, mapping pairs of types to the corresponding type casting function names. This map is crucial for ensuring that the compiler can perform type conversions efficiently during semantic analysis.

### Code Generation

The `cgen.cc` file is responsible for generating Python code from the Abstract Syntax Tree (AST) constructed during the syntax analysis phase. The code generation process leverages predefined templates to produce Python code that can be executed in the Saytring Runtime Environment. This section provides a detailed analysis of key sections of the `cgen.cc` file, focusing on how the code generation functions handle different types of expressions and constructs in the Saytring language.

#### Code Generation for Expressions

The `code_generate()` function is a virtual function defined in the `Expression` class, which is overridden by each specific expression type to generate the corresponding Python code. The generated code is appended to an output string stream (`generated_code`), which is later written to the output file.

##### Example: Code Generation for Variable Declarations

The `Var_Decl_Expr` class represents a variable declaration in the AST. The `code_generate()` function for this class generates Python code to declare a variable using the `SaytringVar` class, which is part of the Saytring Runtime Environment.

```cpp
std::string Var_Decl_Expr::code_generate() {
  std::ostringstream buf;
  std::unordered_map<std::string, std::string> params;

  params.clear();
  params["name"] = this->identifier->get_string();
  params["init"] = this->init->code_generate();
  if (this->init->type == _string)
    params["type"] = "STRING";
  else if (this->init->type == _int)
    params["type"] = "INT";
  else if (this->init->type == _bool)
    params["type"] = "BOOL";
  else
    params["type"] = "NULL_TYPE";
  buf << cg->generate("var_decl", params);

  return buf.str(); // to std::string
}
```

- **Template Parameters**: The function constructs a map of parameters (`params`) that are used to fill in the placeholders in the `var_decl` template. The `name` parameter is the identifier of the variable, and the `init` parameter is the initialization expression.
- **Type Determination**: The type of the initialization expression is determined, and the corresponding type name (`STRING`, `INT`, `BOOL`, or `NULL_TYPE`) is assigned to the `type` parameter.
- **Code Generation**: The `cg->generate("var_decl", params)` function call generates the Python code for the variable declaration using the `var_decl` template. The generated code is appended to the `buf` string stream and returned as a string.

##### Example: Code Generation for Function Calls

The `Direct_Call_Expr` class represents a direct function call in the AST. The `code_generate()` function for this class generates Python code to call a function, including the caller, arguments, and return identifier.

```cpp
std::string Direct_Call_Expr::code_generate() {
  std::unordered_map<std::string, std::string> params;

  params["name"] = this->func_name->get_string();

  // Need to reverse the list, since yacc has collected args in inverse order
  std::ostringstream arg_buf;
  arg_buf << this->id->code_generate();

  int arg_size = arg_list->size();
  // Adjust ','
  if (arg_size > 0) {
    if (this->id->is_nil())
      arg_buf << arg_list->at(arg_size - 1)->code_generate();
    else
      arg_buf << ", " << arg_list->at(arg_size - 1)->code_generate();
  }
  // Append rest args
  if (arg_size > 1)
    for (size_t i = arg_size - 1; i > 0; i--)
      arg_buf << ", " << arg_list->at(i - 1)->code_generate();
  // Append return_id
  if (!return_id->is_nil())
    arg_buf << ", ";
  arg_buf << this->return_id->code_generate();
  params["params"] = arg_buf.str();

  return cg->generate("func_call", params);
}
```

- **Template Parameters**: The function constructs a map of parameters (`params`) that are used to fill in the placeholders in the `func_call` template. The `name` parameter is the name of the function being called.
- **Argument Reversal**: The arguments are collected in reverse order by the parser, so the function reverses the order of the arguments before generating the code.
- **Argument and Return Identifier**: The function generates code for each argument and the return identifier, appending them to the `arg_buf` string stream. The resulting string is assigned to the `params["params"]` parameter.
- **Code Generation**: The `cg->generate("func_call", params)` function call generates the Python code for the function call using the `func_call` template. The generated code is returned as a string.

#### Code Templates in `template.h`

The `template.h` file defines a set of macros that serve as templates for generating Python code. These templates are used by the `Code_Generator` class to produce Python code for different types of expressions and constructs in the Saytring language.

##### Example: Variable Declaration Template

The `TEMPLATE_VAR_DECL` macro defines the template for generating Python code to declare a variable.

```cpp
#define TEMPLATE_VAR_DECL "{name} = SaytringVar({init}, DataType.{type})"
```

- **Placeholders**: The template includes placeholders for the variable name (`{name}`), initialization expression (`{init}`), and type (`{type}`). These placeholders are replaced with the actual values during code generation.

##### Example: Function Call Template

The `TEMPLATE_FUNC_CALL` macro defines the template for generating Python code to call a function.

```cpp
#define TEMPLATE_FUNC_CALL "{name}({params})"
```

- **Placeholders**: The template includes placeholders for the function name (`{name}`) and the parameters (`{params}`). These placeholders are replaced with the actual values during code generation.

These examples illustrate how the `cgen.cc` file and the `template.h` file work together to generate Python code from the AST, ensuring that the generated code is both syntactically correct and semantically meaningful.

## Main Function and Flag Handling

The `main.cc` file serves as the entry point of the Saytring compiler, orchestrating the entire compilation process. It handles command-line arguments, manages input and output files, and coordinates the phases of compilation, including lexical analysis, syntax analysis, semantic analysis, and code generation. The `main()` function is the central hub that drives the compilation process, while the `flag_handler.cc` file provides the logic for parsing and handling command-line flags.

### Example: Parsing Command-Line Flags

The `parse_flags()` function in `flag_handler.cc` is responsible for parsing command-line arguments and populating a map with the parsed flags. This function ensures that the compiler can handle various options and configurations provided by the user.

```cpp
std::unordered_map<std::string, std::string> parse_flags(int argc, char *argv[]) {
  std::unordered_map<std::string, std::string> parsed_flags;

  for (const auto &flag : flags) {
    parsed_flags[flag.name] = flag.default_value;
  }

  for (int i = 1; i < argc; ++i) {
    std::string arg = argv[i];
    bool flag_found = false;

    for (const auto &flag : flags) {
      if (arg == flag.name || (flag.short_name != '\0' && arg == std::string("-") + flag.short_name)) {
        flag_found = true;
        if (flag.has_argument) {
          if (i + 1 < argc) {
            parsed_flags[flag.name] = argv[i + 1];
            ++i;
          } else {
            std::cerr << "Error: " << flag.name << " requires an argument." << std::endl;
            exit(1);
          }
        } else {
          parsed_flags[flag.name] = "true";
        }
      }
    }

    if (!flag_found && arg.substr(0, 1) == "-") {
      std::cerr << "Error: Undefined flag " << arg << " provided." << std::endl;
      exit(1);
    }
  }
  return parsed_flags;
}
```

- **Default Values**: The function initializes the `parsed_flags` map with default values for each flag.
- **Argument Parsing**: It iterates through the command-line arguments, matching them against the predefined flags. If a flag requires an argument, the function ensures that the next argument is available and assigns it to the flag.
- **Error Handling**: If an undefined flag is encountered, the function prints an error message and exits.

### Example: Main Function

The `main()` function in `main.cc` orchestrates the entire compilation process, from parsing command-line flags to running the generated Python code. It handles input and output files, performs syntax and semantic checks, and generates Python code.

```cpp
int main(int argc, char **argv) {
  auto start = std::chrono::high_resolution_clock::now();

  // Parse command line flags
  parsed_flags = parse_flags(argc, argv);

  // Handle --version and --help flags
  if (parsed_flags["--version"] == "true") {
    display_version();
    return 0;
  }
  if (parsed_flags["--help"] == "true") {
    display_help();
    return 0;
  }

  // Set input and output filenames based on parsed flags
  input_filename = const_cast<char *>(parsed_flags["--input"].empty() ? "<stdin>" : parsed_flags["--input"].c_str());
  output_filename = const_cast<char *>(parsed_flags["--output"].empty() ? "output.py" : parsed_flags["--output"].c_str());
  runtime_filename = const_cast<char *>(parsed_flags["--runtime"].empty() ? "<stdin>" : parsed_flags["--runtime"].c_str());
  FILE *inputFile = stdin;
  if (input_filename != std::string("<stdin>")) {
    inputFile = fopen(input_filename, "r");
    if (!inputFile) {
      perror("Failed to open file");
      return 1;
    }
  }
  yyin = inputFile;

  // Syntax Parsing
  if (yyparse() != 0) {
    printf("Compilation terminated due to syntax errors.\n");
    return 0;
  }
  printf("No syntax errors detected.\n");
  if (inputFile != stdin)
    fclose(inputFile);

  // Semantic Check
  ast_root->semant_check();
  if (semant_warn_count > 0)
    printf("%d warnings detected, which may lead to unexpected behavior.\n", semant_warn_count);
  if (semant_error_count > 0) {
    printf("Compilation terminated due to %d semantic errors.\n", semant_error_count);
    return 0;
  }
  printf("No semantic errors detected.\n");

  // Code generation
  ast_root->code_generation();

  // Calculate compilation time
  auto end = std::chrono::high_resolution_clock::now();
  std::chrono::duration<double> diff = end - start;
  std::cout << "\nCompilation completed in " << diff.count() << " seconds.\n";

  printf("Compilation successful.\n");
  printf("Ready to go (*)o\n");

  // Run code if --run flag is set to "true"
  if (parsed_flags["--run"] == "true") {
    printf("\n--------Saytring v%s--------\n", _VERSION_);
    int result = system(("python " + std::string(output_filename)).c_str());
    if (result != 0) {
      printf("Error: Failed to execute the generated Python script.\n");
      printf("Suggestion: Ensure Python is installed and accessible in your PATH. Check the script for any runtime errors.\n");
    }
  }

  return 0;
}
```

- **Flag Parsing**: The `main()` function starts by parsing command-line flags using the `parse_flags()` function.
- **Input/Output Handling**: It sets the input and output filenames based on the parsed flags and opens the input file for reading.
- **Syntax Parsing**: The function calls `yyparse()` to perform syntax analysis. If syntax errors are detected, the compilation process is terminated.
- **Semantic Analysis**: The `semant_check()` function is called on the AST root to perform semantic analysis. Warnings and errors are reported if any are found.
- **Code Generation**: The `code_generation()` function is called to generate Python code from the AST.
- **Execution**: If the `--run` flag is set, the generated Python script is executed using the `system()` function.

These examples illustrate how the `main.cc` and `flag_handler.cc` files work together to provide a seamless and user-friendly compilation experience for the Saytring language.

## Compilation and Execution Instructions

To compile and run the Saytring compiler, follow these steps:

### 1. Compilation

The compilation process is managed by the `Makefile` located in the `Saytring/src` directory. To compile the Saytring compiler, navigate to the `Saytring/src` directory and run the following command:

```bash
make all
```

This command will:

- Generate the lexical analyzer (`lexer.yy.cc`) using Flex.
- Generate the syntax analyzer (`parser.tab.cc` and `parser.tab.h`) using Bison.
- Compile all the source files into object files (`main.o`, `lexer.o`, `parser.o`, etc.).
- Link the object files to create the final executable, `saytringc`.

The compiled executable and intermediate files will be moved to the `../build` directory as specified in the `Makefile`.

### 2. Running the Compiler

The Saytring compiler accepts several command-line flags to customize its behavior. Below is a list of available flags and their descriptions:

| Flag        | Short Flag | Description                                     | Default Value           |
| ----------- | ---------- | ----------------------------------------------- | ----------------------- |
| `--input`   | `-i`       | Specify the input file path                     | `<stdin>`               |
| `--output`  | `-o`       | Specify the output file path                    | `output.py`             |
| `--runtime` | `-t`       | Specify the runtime file path                   | `../runtime/runtime.py` |
| `--debug`   | `-d`       | Enable debug mode for detailed logs             | `false`                 |
| `--run`     | `-r`       | Run the program automatically after compilation | `false`                 |
| `--help`    | `-h`       | Display this help message and exit              | `false`                 |
| `--version` | `-v`       | Display the version information and exit        | `false`                 |

#### Example Commands

1. **Compile and run a Saytring program from a file:**

   ```bash
   ./saytringc --input=../test/sin.say --output=output.py --run
   ```

   This command will:

   - Read the Saytring source code from `../test/sin.say`.
   - Generate the corresponding Python code in `output.py`.
   - Automatically run the generated Python script.

2. **Compile a Saytring program and specify a custom runtime file:**

   ```bash
   ./saytringc --input=../test/sin.say --output=output.py --runtime=custom_runtime.py
   ```

   This command will:

   - Use `custom_runtime.py` as the runtime environment for the generated Python code.

3. **Enable debug mode and compile a Saytring program:**

   ```bash
   ./saytringc --input=../test/sin.say --output=output.py --debug
   ```

   This command will:

   - Enable debug mode, which provides detailed logs during the compilation process.
   - Generate the Python code in `output.py`.

4. **Compile a Saytring program and specify a different output file:**

   ```bash
   ./saytringc --input=../test/sin.say --output=custom_output.py
   ```

   This command will:

   - Generate the Python code in `custom_output.py` instead of the default `output.py`.

5. **Display help and version information:**

   ```bash
   ./saytringc --help
   ./saytringc --version
   ```

### 3. Cleaning Up

To clean up the build directory and remove all generated files, run the following command:

```bash
make clean
```

This command will remove the `saytringc` executable, object files, and intermediate files from the `../build` directory.

### 4. Testing

To test the compiler with a sample Saytring program, use the `dotest` target in the `Makefile`:

```bash
make dotest
```

This command will compile and run the Saytring compiler with the `../test/sin.say` file, ensuring that the compiler works as expected.
